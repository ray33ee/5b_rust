
- Create an IR that all supported types can convert to and from (IR should be something like `[u8]`)
- Create two traits
  - ToIR
    - `fn convert(value: & str) -> Box<IR>` returns the IR converted from a value (assumes conversion is possible)
    - `fn identify(value: & str) -> bool` returns true if it is possible to convert `value` to `T`
  - FromIR
    - `fn identify(byte: AsRef<IR>) -> bool` returns true if it is possible to convert the IR data into `T`
    - `fn convert(byte: AsRef<IR>) -> Self` returns an object of type T converted from the IR (assumes conversion is possible)
- For a given input display all possible conversions. Allow the user to change the input to one of these conversions.
  - This allows an arbitrary number of conversions without having to keep entering data and identifying it
- ToIR implementations:
  - Hex, binary, decimal, octal
  - AScii/unicode string
  - All possible bases (using BaseCrack API)
  - Python string formatted bytes list
  - 16, 32 and 64-bit floats
  - DateTime
  - IpV4, IpV6 (variant: optional 16-bit port)
  - GUID
  - Html colours
  - List of bytes (hex or decimal formatted)
- FromIR implementations:
  - Hex, binary, decimal, octal
  - AScii/unicode string
  - All possible bases (using BaseCrack API)
  - Python string formatted bytes list
  - 16, 32 and 64-bit floats
  - DateTime
  - IpV4, IpV6
  - GUID
  - All combinations of signed/unsigned 8, 16, 32, 64 and 128 bit integers
  - Colours
  - List of bytes (hex or decimal formatted)
- Allow each convertable type to have variants too (for example base64 allows for padding and no padding, URL characters, etc.)
  - Allow for infinite variante (Such as used in DateTime formatting)
  - Variants should be expressed as strings, to allow infinite combinations and create meaningful names
  - The variant SHOULD be specified when encoding, unless we can deduce it.
    - Create an enum with DEDUCE and CHOSE(variant)
      - If DEDUCE is used, we try to figure out the variant. We return deduced_variant
      - If CHOSE(variant) is used, we simply use the variant
  - The variant MUST be specified when decoding
  